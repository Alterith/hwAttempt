1)0x602010

2)$2 = {_flags = -72539000, _IO_read_ptr = 0x0, _IO_read_end = 0x0, 
  _IO_read_base = 0x0, _IO_write_base = 0x0, _IO_write_ptr = 0x0, 
  _IO_write_end = 0x0, _IO_buf_base = 0x0, _IO_buf_end = 0x0, 
  _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, 
  _chain = 0x7ffff7dd4640 <_IO_2_1_stderr_>, _fileno = 3, _flags2 = 0, 
  _old_offset = 0, _cur_column = 0, _vtable_offset = 0 '\000', _shortbuf = "", 
  _lock = 0x6020f0, _offset = -1, __pad1 = 0x0, __pad2 = 0x602100, __pad3 = 0x0, 
  __pad4 = 0x0, __pad5 = 0, _mode = 0, _unused2 = '\000' <repeats 19 times>}
(gdb) p &wc

3)0x400700 

4)I currently see all variables and functions stored on the stack in order of execution desc

5)i see the currently executing frame and the starting mem address of the stack frame in rip, and the address of the instruction to be continued after this completion under save rip, the called by frame is the address of the stack frame which called for this instruction.The arglist is clearly he starting address of our arguments for the current instruction in this case wc.Locals is address of local vars. Previous frame's sp is the stack pointer of the prev frame's stack pointer to its caller frame.

6)rdi contains infile value i.e. the location of the test.txt used.
rip is storing my address of wc+16
r8 might be storing the base of my address space
